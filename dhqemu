#!/bin/bash

# DocHat QEMU
# A skinny hypervisor implemented in #!/bin/bash
# Written by George Shearer <george@shearer.tech>

# ----------------------------------------------------------------------------

DHQ_VERSION=2026012601

# paths that will be searched for dhqemu.conf
DHQ_SEARCH="$XDG_CONFIG_HOME/dhqemu $HOME/.config/dhqemu /etc /usr/local/etc"

# ----------------------------------------------------------------------------

dh_header()
{
  cat <<_EOF_

·▄▄▄▄         ▄▄·  ▄ .▄ ▄▄▄· ▄▄▄▄▄
██▪ ██ ▪     ▐█ ▌▪██▪▐█▐█ ▀█ •██  
▐█· ▐█▌ ▄█▀▄ ██ ▄▄██▀▐█▄█▀▀█  ▐█.▪
██. ██ ▐█▌.▐▌▐███▌██▌▐▀▐█ ▪▐▌ ▐█▌·
▀▀▀▀▀•  ▀█▄▀▪·▀▀▀ ▀▀▀ · ▀  ▀  ▀▀▀ 

   DHQEMU Version: $DHQ_VERSION

    Written by George Shearer
       george@shearer.tech

_EOF_
}

# ----------------------------------------------------------------------------

dh_usage()
{
  cat <<_EOF_

Usage: dhqemu command guestname [args]

Where command is one of:

  boot      :: power on guest
  bootall   :: boot all dhqemu guests with bootall=true
  iceboot   :: power on guest but in cpu suspend mode
  reset     :: issue qemu 'system_reset'
  wake      :: issue qemu 'system_wakeup'
  shut      :: attempt graceful shutdown
  shutall   :: attempt graceful shutdown for all dhqemu guests
  kill      :: immediately power off guest
  killall   :: immediately power off all dhqemu guests
  freeze    :: suspend execution
  thaw      :: continue execution
  mon       :: connect to qemu monitor
  list      :: list of dhqemu guests
  dir       :: show folder of guest
  pid       :: shows list of running qemu instances
  show      :: shows the qemu command line used to boot VM
  backup    :: create backup archive of guest directory
  delete    :: delete the guest folder, next boot will generate files
  unmap     :: unmap file to usb-disk
  unplug    :: unplug virtual usb device created with 'plug'

commands with args:
  clone   guestname newname    :: create new vm
  commit  guestname [disknum]  :: commit change disk
  revert  guestname [disknum]  :: erase change disk and recreate
  erase   guestname [disknum]  :: erase base disk and recreate
  map     guestname /path/to/example.iso    :: map a local file to vm usb disk
  plug    guestname hostbus hostdev [vmbus] :: 'plug' a local usb dev to vm usb bus

Note: Use the 'lsusb' command to find hostbus and hostdev for use with the plug command. Don't include the 0 padding. The third argument (vmbus) is defined in your guest's configuration. This defaults to usb.0 if not specified.

_EOF_
  exit 1
}

# ----------------------------------------------------------------------------

dh_killswtpm()
{
  if [[ -f "$DHQ_VMPATH/$DHQ_VMNAME/swtpm.pid" ]]; then
    swtpm_pid=$(cat $DHQ_VMPATH/$DHQ_VMNAME/swtpm.pid)
    if [[ $(cat /proc/$swtpm_pid/comm) == swtpm ]]; then
      echo Stopping swtpm PID $swtpm_pid
      kill -15 $swtpm_pid &>/dev/null
      sleep 1
      kill -9 $swtpm_pid &>/dev/null
    fi
  fi
}

# ----------------------------------------------------------------------------

dh_error()
{
  [[ -z $1 || $1 -eq 0 ]] && return
  rm -f "$DHQ_LOCKFILE"
  exitcode=$1
  shift

  if [[ -n $exitcode && $exitcode -ne 99 ]]; then
    echo -e "dhqemu error ($exitcode): ${@}"
  else
    echo -e "dhqemu error: ${@}"
  fi

  [[ -n $exitcode ]] && exit $exitcode
  exit 1
}

# ----------------------------------------------------------------------------

dh_mklock()
{
  x=0
  while [[ -f $DHQ_LOCKFILE ]]; do
    echo "dhqemu: $DHQ_LOCKFILE exists - sleeping 2 seconds"
    sleep 2
    x=$(( $x + 1 ))

    (( $x > 4 )) &&
      dh_error 99 "dhqemu: unable to obtain lock. check for hung processes and/or delete $DHQ_LOCKFILE"
  done
  touch "$DHQ_LOCKFILE"
  dh_error $? "unable to create lockfile $DHQ_LOCKFILE"
}

# ----------------------------------------------------------------------------

dh_monitor()
{
  socat - "UNIX-CONNECT:$DHQ_VMPATH/$DHQ_VMNAME/monitor.sock"
}

# ----------------------------------------------------------------------------

dh_runcheck()
{
  local isrunning=false

  [[ -n $DHQ_UUID && -n $(/bin/ps xa | grep "uuid $DHQ_UUID" | grep -v grep) ]] &&
    isrunning=true

  [[ $1 == "run" && $isrunning == "true" ]] &&
    dh_error 99 "$DHQ_VMNAME ($DHQ_UUID) is running"

  [[ $1 == "norun" && $isrunning == "false" ]] &&
    dh_error 99 "$DHQ_VMNAME ($DHQUUID) is not running"
}

# ----------------------------------------------------------------------------

dh_adjusthuge()
{
  local x freehp curhp newhp attempts

  x=$(( ($DHQ_MEM / 2) + 100 ))

  if (( $x > 0 )); then

    freehp=$(grep -E '^HugePages_Free' /proc/meminfo | awk '{ printf $NF }')

    if (( $x > $freehp )); then

      attempts=0
      while true; do
        curhp=$(cat /proc/sys/vm/nr_hugepages)
        newhp=$(( $curhp + $x - $freehp ))

        echo -n "increasing kernel hugepage count from $curhp to "

        echo $newhp | sudo tee /proc/sys/vm/nr_hugepages
        dh_error $? "attempt to set hugepages to $newhp failed"

        freehp=$(grep -E '^HugePages_Free' /proc/meminfo | awk '{ printf $NF }')

        if (( $freehp < $x )); then
          attempts=$(( $attempts + 1 ))
          if (( $attempts > 2 )); then
            echo
            dh_error 99 "failed to increase hugepages to $newhp"
          else
            echo failed. trying again
            sleep 1
          fi
        else
          break
        fi
      done

      echo success
      echo
      grep -E '^HugePages' /proc/meminfo
      echo
    fi
  fi
}

# ----------------------------------------------------------------------------

dh_reclaimhuge()
{
  x=$(( ($DHQ_MEM / 2) + 100 ))

  if (( $x > 0 )); then
    numhp=$(grep -E '^HugePages_Total' /proc/meminfo | awk '{ printf $NF }')
    hpleft=$(( $numhp - $x ))
    if (( $hpleft < 0 )); then
      echo 0 | sudo tee /proc/sys/vm/nr_hugepages
      echo unallocating all huge pages
    else
      echo $hpleft | sudo tee /proc/sys/vm/nr_hugepages &>/dev/null
      echo unallocated $x huge pages
    fi
  fi
}

# ----------------------------------------------------------------------------

dh_kill()
{
  echo quit | dh_monitor
  sleep 1

  [[ -f "$DHQ_VMPATH/$DHQ_VMNAME.pid" ]] &&
    kill -9 $(cat $DHQ_VMPATH/$DHQ_VMNAME/$DHQ_VMNAME.pid | head -1)
}

# ----------------------------------------------------------------------------

dh_shutdown()
{
  local x=0 y=0

  while [[ $y -lt 2 ]]; do
    if [[ -n $(echo info status | dh_monitor | grep -a paused) ]]; then
      echo "Guest $DHQ_VMNAME is asleep, attempting to wake..."
      echo system_wakeup | dh_monitor
      echo
      sleep 5
    fi

    echo -n "Sending shutdown request to guest \"$DHQ_VMNAME\" ..."
    echo system_powerdown | dh_monitor

    echo
    echo Waiting for system to shutdown for up to $DHQ_SHUTWAIT seconds

    x=0
    while [[ $x -lt $DHQ_SHUTWAIT ]]; do
      if [[ -n $(/bin/ps xa | grep "uuid $UUID" | grep -v grep) ]]; then
        echo System is still running for $x seconds...
        sleep 1
      else
        return
      fi
      x=$(($x + 1))
    done

    if [[ -n $(/bin/ps xa | grep "uuid $DHQ_UUID" | grep -v grep) ]]; then
      echo guest \"$DHQ_VMNAME\" has not gracefully shutdown
    fi

    y=$(($y + 1))
  done

  if [[ $y -ge 2 ]]; then
    echo "guest $DHQ_VMNAME has ignored $y graceful shutdown requests"
    dh_kill $DHQ_VMNAME
  fi
}

# ----------------------------------------------------------------------------

dh_backup()
{
  [[ ! -d "$DHQ_VMPATH/$DHQ_VMNAME" ]] &&
    dh_error 99 "guest folder does not exist: $DHQ_VMPATH/$DHQ_VMNAME"

  if [[ ! -d "$DHQ_BACKUPPATH" ]]; then
    mkdir "$DHQ_BACKUPPATH"
    dh_error $? "unable to create folder $DHQ_BACKUPPATH"
    chmod $DHQ_DPERM "$DHQ_BACKUPPATH"
  fi

  echo
  echo backup underway - do not start the VM until completed

  tar -cvpf - "$DHQ_VMPATH/$DHQ_VMNAME" | $DHQ_CF >"$DHQ_BACKUPPATH/$DHQ_VMNAME.dhqemu.tar.$DHQ_CFEXT"
  dh_error $? "failed to create backup archive for $DHQ_VMNAME"

  chmod $DHQ_FPERM "$DHQ_BACKUPPATH/$DHQ_VMNAME.dhqemu.tar.$DHQ_CFEXT"

  echo
  echo backup complete - it is now safe to start the vm
}

# ----------------------------------------------------------------------------

dh_commit()
{
  x=0
  while [[ -n "${DHQ_VDISK[$x]}" ]]; do
    if [[ -n $1 && $1 -ne $x ]]; then
      x=$(( $x + 1 ))
      continue
    fi

    echo -e "\nflushing disk $DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"

    qemu-img commit -b "$DHQ_VMPATH/$DHQ_VMNAME/base$x.raw" -p "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    dh_error $? "failed to flush vdisk $DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"

    rm -f "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    qemu-img create -f qcow2 -b "$DHQ_VMPATH/$DHQ_VMNAME/base$x.raw" -F raw "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    dh_error $? "error creating change disk $DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    chmod $DHQ_FPERM "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    x=$(( $x + 1 ))
  done
  echo success
}

# ----------------------------------------------------------------------------

dh_revert()
{
  x=0
  while [[ -n "${DHQ_VDISK[$x]}" ]]; do
    if [[ -n $1 && $1 -ne $x ]]; then
      x=$(( $x + 1 ))
      continue
    fi

    rm -f "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    qemu-img create -f qcow2 -b "$DHQ_VMPATH/$DHQ_VMNAME/base$x.raw" -F raw "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    dh_error $? "error creating change disk $DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    chmod $DHQ_FPERM "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"

    x=$(( $x + 1 ))
  done
  echo success
}

# ----------------------------------------------------------------------------

dh_erase()
{
  x=0
  while [[ -n "${DHQ_VDISK[$x]}" ]]; do
    if [[ -n $1 && $1 -ne $x ]]; then
      x=$(( $x + 1 ))
      continue
    fi

    rm -vf "$DHQ_VMPATH/$DHQ_VMNAME/base$x.raw"
    rm -vf "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    x=$(( $x + 1 ))
  done
  echo success
}

# ----------------------------------------------------------------------------

dh_launchswtpm()
{
  local swtpm_pid

  if [[ -f "$DHQ_VMPATH/$DHQ_VMNAME/swtpm.pid" ]]; then
    swtpm_pid=$(cat $DHQ_VMPATH/$DHQ_VMNAME/swtpm.pid)
    if [[ $(cat /proc/$swtpm_pid/comm) == swtpm ]]; then
      echo software TPM emulator daemon is at pid $swtpm_pid
      return
    fi
  fi

  [[ ! -x $(type -p swtpm) ]] &&
    dh_error 99 "$DHQ_VMNAME requests TPM emulation but swtpm is not installed"

  swtpm socket --terminate --tpm2 \
    --tpmstate dir="$DHQ_VMPATH/$DHQ_VMNAME" \
    --pid file="$DHQ_VMPATH/$DHQ_VMNAME/swtpm.pid" \
    --ctrl type=unixio,path="$DHQ_VMPATH/$DHQ_VMNAME/swtpm.sock" \
    --log file="$DHQ_VMPATH/$DHQ_VMNAME/swtpm.log",level=1,truncate \
    --daemon

  dh_error $? "unable to start software tpm emulator service"
  swtpm_pid=$(cat $DHQ_VMPATH/$DHQ_VMNAME/swtpm.pid)
  echo "Launched software TPM emulator for $DHQ_VMNAME (pid: $swtpm_pid)"
}

# ----------------------------------------------------------------------------

dh_createdisks()
{
  local x=0

  while [[ -n "${DHQ_VDISK[$x]}" ]]; do
    if [[ ! -f "$DHQ_VMPATH/$DHQ_VMNAME/base${x}.raw" ]]; then
      qemu-img create -f raw "$DHQ_VMPATH/$DHQ_VMNAME/base${x}.raw" ${DHQ_VDISK[$x]}
      dh_error $? "unable to create disk #$x"
      chmod $DHQ_FPERM "$DHQ_VMPATH/$DHQ_VMNAME/base${x}.raw"
    fi

    if [[ ! -f "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2" ]]; then
      qemu-img create -f qcow2 -b "$DHQ_VMPATH/$DHQ_VMNAME/base$x.raw" -F raw "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
      dh_error $? "unable to create change disk #$x"
      chmod $DHQ_FPERM "$DHQ_VMPATH/$DHQ_VMNAME/change$x.qcow2"
    fi
    x=$(( $x + 1 ))
  done
}

# ----------------------------------------------------------------------------

dh_firstboot()
{
  local x=0 ethmacs=""

  mkdir "$DHQ_VMPATH/$DHQ_VMNAME"
  dh_error $? "unable to create folder $DHQ_VMPATH/$DHQ_VMNAME"
  chmod $DHQ_DPERM "$DHQ_VMPATH/$DHQ_VMDIR"

  [[ $DHQ_UUID == "generate" || -z $DHQ_UUID ]] && DHQ_UUID=$(uuidgen -r)

  echo DHQ_UUID=$DHQ_UUID >"$DHQ_VMPATH/$DHQ_VMNAME/persist.vars"
  dh_error $? "unable to create $DHQ_VMPATH/$DHQ_VMNAME/persist.vars"
  chmod $DHQ_FPERM "$DHQ_VMPATH/$DHQ_VMNAME/persist.vars"

  while [[ -n ${DHQ_MAC[$x]} ]]; do
    [[ ${DHQ_MAC[$x]} == "generate" ]] &&
      DHQ_MAC[$x]=$(tr -dc A-F0-9 < /dev/urandom | head -c 10 | sed -r 's/(..)/\1:/g;s/:$//;s/^/02:/')
    echo DHQ_MAC\[$x\]=${DHQ_MAC[$x]} >>"$DHQ_VMPATH/$DHQ_VMNAME/persist.vars"
    x=$(( $x + 1 ))
  done

  if [[ $DHQ_FIRMWARE != "bios" ]]; then
    cp -v "$DHQ_NVRAM" "$DHQ_VMPATH/$DHQ_VMNAME/nvram.raw"
    dh_error $? "failed to create nvram for $DHQ_VMNAME"
    chmod $DHQ_FPERM "$DHQ_VMPATH/$DHQ_VMNAME/nvram.raw"
  fi
}

# ----------------------------------------------------------------------------

dh_preboot()
{
  local x=0 drives="" iots="" total_vdisks=0 blockconts="" optical="" boot="" tpm="" ram="" vnics="" spice="" cpu="" vfs=""

  [[ $DHQ_VIRGL == "true" && ! -x $DHQ_VIRGLPATH ]] &&
    dh_error 99 "DHQ_VIRLGLPATH is non-executable: $DHQ_VIRGLPATH"

  [[ ! -d "$DHQ_VMPATH/$DHQ_VMNAME" ]] && dh_firstboot

  [[ $DHQ_FIRMWARE != "bios" ]] &&
    drives="-drive id=pflash0,if=pflash,format=raw,readonly=on,file=$DHQ_FIRMWARE -drive id=pflash1,if=pflash,format=raw,file=$DHQ_VMPATH/$DHQ_VMNAME/nvram.raw"

  while [[ -n "${DHQ_VDISK[$x]}" ]]; do
    drives="$drives -drive id=vdisk${x},if=none,media=disk,cache=unsafe,format=qcow2,aio=io_uring,discard=unmap,file=$DHQ_VMPATH/$DHQ_VMNAME/change${x}.qcow2"
    blockconts="$blockconts -device virtio-blk-pci,id=bcont${x},drive=vdisk${x},config-wce=off,iothread=iot${x},bootindex=$(( $x + 1 ))"
    iots="$iots -object iothread,id=iot${x}"
    x=$(( $x + 1 ))
  done
  total_vdisks=$x

  x=0
  while [[ -n "${DHQ_CD[$x]}" ]]; do
    [[ ! -f "${DHQ_CD[$x]}" ]] &&
      dh_error 99 "unable to read ${DHQ_CD[$x]}"
    optical="$optical -drive id=cd$x,if=ide,index=$(( $x + 1 )),media=cdrom,cache=none,format=raw,readonly=on,file=${DHQ_CD[$x]}"
    x=$(( $x + 1 ))
  done

  x=0
  while [[ -n "${DHQ_MAC[$x]}" ]]; do
    [[ -z "${DHQ_BRIDGE[$x]}" ]] &&
      dh_error 99 "no bridge device defined for nic #$x"
    vnics="$vnics -netdev tap,id=vnic$x,ifname=$DHQ_VMNAME-vnic$x,script=no,downscript=no,vhost=on,br=${DHQ_BRIDGE[$x]} -device virtio-net-pci,netdev=vnic$x,mac=${DHQ_MAC[$x]}"
    x=$(( $x + 1 ))
  done

  x=0
  while [[ -n "${DHQ_SHARE[$x]}" ]]; do
    vfs="-chardev socket,id=virtfs${x},path=$DHQ_VMPATH/$DHQ_VMNAME/virtfs${x}.sock -device vhost-user-fs-pci,queue-size=1024,chardev=virtfs${x},tag=virtfs${x} $vfs"
    x=$(( $x + 1 ))
  done

  ram="-m size=${DHQ_MEM}M"
  if [[ $DHQ_HUGE == "true" ]]; then
    ram="$ram -object memory-backend-file,id=pc.ram,size=${DHQ_MEM}M,mem-path=/dev/hugepages,prealloc=on,share=on"
  else
    ram="$ram -object memory-backend-file,id=pc.ram,size=${DHQ_MEM}M,mem-path=/dev/shm,share=on"
  fi

  if [[ -z $DHQ_CPU ]]; then
    x=$(nproc)
    (( $x > 3 )) && x=$(( $x - 2 ))
    cpu="-cpu host -smp ${x},sockets=1,dies=1,cores=${x},threads=1"
  else
    cpu=$DHQ_CPU
  fi

  [[ $DHQ_TPM == "true" ]] &&
    tpm="-chardev socket,id=chrtpm,path=$DHQ_VMPATH/$DHQ_VMNAME/swtpm.sock -tpmdev emulator,id=tpm0,chardev=chrtpm -device tpm-tis,tpmdev=tpm0"

  DHQ_CMD="$DHQ_PREPEND $DHQ_QEMUCMD -name $DHQ_VMNAME $DHQ_MACHINE -uuid $DHQ_UUID $DHQ_SUSPEND -smbios type=1,manufacturer=DocHat,product=DHQEMU,version=$DHQ_VERSION,serial=$DHQ_UUID,uuid=$DHQ_UUID $cpu $ram $DHQ_GLOBAL $DHQ_MISC $DHQ_RTC $DHQ_BOOTSEQ $DHQ_DISPLAY $DHQ_AUDIO $iots $drives $blockconts $optical $DHQ_VIDEO $DHQ_SOUND $DHQ_BALLOON $DHQ_RNG $DHQ_USB $DHQ_SERIAL $vfs $DHQ_TABLET $tpm $vnics $DHQ_SPICE $DHQ_SPICEAGENT $DHQ_SPICEREDIR $DHQ_VNC -pidfile $DHQ_VMPATH/$DHQ_VMNAME/$DHQ_VMNAME.pid -monitor unix:$DHQ_VMPATH/$DHQ_VMNAME/monitor.sock,server,nowait $DHQ_APPEND"
}

# ----------------------------------------------------------------------------

dh_showqemu()
{
  echo
  echo QEMU command line for guest \"$DHQ_VMNAME\"
  echo -----------------------------------------------------------------------
  echo
  echo $DHQ_CMD | sed -e 's/ -/ \\\n -/g'
  echo
  echo -----------------------------------------------------------------------
}

# ----------------------------------------------------------------------------

dh_unconfnet()
{
  local x

  sudo ip link delete dev dhqtap &>/dev/null

  x=0
  while [[ -n ${DHQ_MAC[$x]} && ${DHQ_BRIDGE[$x]} && ${DHQ_MTU[$x]} ]]; do
    sudo ip link set nomaster dev $DHQ_VMNAME-vnic$x &>/dev/null
    sudo ip link delete dev $DHQ_VMNAME-vnic$x &>/dev/null
    x=$(( $x + 1 ))
  done
}

dh_confnet()
{
  local x

  x=0
  while [[ -n ${DHQ_MAC[$x]} && ${DHQ_BRIDGE[$x]} && ${DHQ_MTU[$x]} ]]; do
    sudo ip tuntap add dev dhqtap mode tap group $(id -gn)
    dh_error $? "error creating tap device for virtual nic $x"

    sudo ip link set name $DHQ_VMNAME-vnic$x dhqtap
    if (( $? != 0 )); then
      dh_unconfnet
      dh_error 99 "unable to set tap device name"
    fi

    sudo ip link set up dev $DHQ_VMNAME-vnic$x
    if (( $? != 0 )); then
      dh_unconfnet
      dh_error 99 "unable to set tap device state to up"
    fi

    sudo ip link set mtu ${DHQ_MTU[$x]} dev $DHQ_VMNAME-vnic$x
    if (( $? != 0 )); then
      dh_unconfnet
      dh_error 99 "unable to set tap device mtu to ${DHQ_MTU[$x]}"
    fi

    if [[ ${DHQ_BRIDGE[$x]} != none ]]; then
      sudo ip link set master ${DHQ_BRIDGE[$x]} dev $DHQ_VMNAME-vnic$x
      if (( $? != 0 )); then
        dh_unconfnet
        dh_error 99 "unable to set tap device $DHQ_VMNAME-vnic$x master to ${DHQ_BRIDGE[$x]}"
      fi
    fi

    x=$(( $x + 1 ))
  done
}

# ----------------------------------------------------------------------------

dh_unconfnet()
{
  local x

  x=0
  while [[ -n ${DHQ_MAC[$x]} && ${DHQ_BRIDGE[$x]} && ${DHQ_MTU[$x]} ]]; do
    sudo ip link set down dev $DHQ_VMNAME-vnic$x
    sudo ip link set nomaster dev $DHQ_VMNAME-vnic$x
    sudo ip link delete dev $DHQ_VMNAME-vnic$x
    x=$(( $x + 1 ))
  done
}

# ----------------------------------------------------------------------------

dh_boot()
{
  local qemu_errno virgl_pid x=0

  rm -f "$DHQ_VMPATH/$DHQ_VMNAME/$DHQ_VMNAME.pid" &>/dev/null

  if [[ $DHQ_VIRGL == "true" ]]; then
    echo -n "Launching virgl user-space renderer "
    $DHQ_VIRGLPATH --no-fork --socket-path="$DHQ_VMPATH/$DHQ_VMNAME/vgpu.sock" &
    virgl_pid=$!
    sleep 0.5
    [[ ! -d /proc/$virgl_pid ]] &&
      dh_error 99 "unable to launch $DHQ_VIRGLPATH"
    echo "(pid: $virgl_pid)"
  fi

  x=0
  while [[ -n "${DHQ_SHARE[$x]}" ]]; do
    $DHQ_VIOFSDPATH --shared-dir "${DHQ_SHARE[$x]}" \
      --socket-path "$DHQ_VMPATH/$DHQ_VMNAME/virtfs${x}.sock"  &
    vfsdpid[$x]=$!
    sleep 0.1
    if [[ ! -d /proc/${vfsdpid[$x]} ]]; then
      [[ -n $virgl_pid && -f /proc/$virgl_pid/comm ]] &&
        echo killing virgl render at pid $virgl_pid && kill -15 $virgl_pid
      dh_error 99 "unable to launch $DHQ_VIOFSDPATH for share ${DHQ_SHARE[$x]}"
    fi
    x=$(( $x + 1 ))
  done

  [[ $DHQ_TPM == "true" ]] && dh_launchswtpm

  if [[ $DHQ_HUGE == "true" ]]; then
    dh_adjusthuge
    (( $EUID != 0 )) && sudo chmod o+w /dev/hugepages
  fi

  dh_confnet

  $DHQ_QEMUBIN $DHQ_CMD
  qemu_errno=$?

  x=0
  while [[ -n "${DHQ_SHARE[$x]}" ]]; do
    [[ -d /proc/${vfsdpid[$x]} ]] && kill -15 ${vfsdpid[$x]}
    x=$(( $x + 1 ))
  done

  dh_unconfnet
  dh_killswtpm

  [[ $DHQ_HUGE == "true" ]] && dh_reclaimhuge

  [[ -n $virgl_pid && -f /proc/$virgl_pid/comm ]] &&
    echo killing virgl render at pid $virgl_pid && kill -15 $virgl_pid

  rm -f "$DHQ_LOCKFILE"

  [[ -z $qemu_errno ]] && dh_error 99 "failed to boot guest"
  [[ $qemu_errno -ne 0 ]] && dh_error $qemu_errno "failed to boot guest"

  echo "Guest $DHQ_VMNAME has exited"
}

# ----------------------------------------------------------------------------

dh_getguestconf()
{
  source "$DHQ_CONFDIR/$1.dhqemu" &>/dev/null
  dh_error $? "unable to read $DHQ_CONFDIR/$1.dhqemu"

  [[ -z $DHQ_VMNAME ]] && dh_error 99 "DHQ_VMNAME undefined"
  [[ -z $DHQ_VMPATH ]] && dh_error 99 "DHQ_VMPATH undefined"
  [[ -z $DHQ_QEMUCMD ]] && dh_error 99 "DHQ_QEMUBIN undefined"
  [[ -z $DHQ_CF ]] && dh_error 99 "DHQ_CF undefined"

  source "$DHQ_VMPATH/$DHQ_VMNAME/persist.vars" &>/dev/null
}

# ----------------------------------------------------------------------------

dh_getconf()
{
  for x in $DHQ_SEARCH; do
    source "$x/dhqemu.conf" &>/dev/null
    if (( $? == 0 )); then
      [[ -z $DHQ_CONFDIR ]] && dh_error 99 "DHQ_CONFDIR undefined"
      return
    fi
  done
  dh_error $? "unable to find dhqemu.conf in paths: $DHQ_SEARCH"
}

# script begin
# ----------------------------------------------------------------------------

(( $EUID == 0 || $UID == 0 )) &&
  dh_error 99 "this script is designed to run without root privilege but it will use sudo when necessary."

dh_getconf

[[ ! -x $(type -p socat) ]] &&
  dh_error 99 "please install socat"

[[ ! -x $(type -p uuidgen) ]] &&
  dh_error 99 "please install uuidgen"

[[ -x $(type -p $DHQ_QEMUBIN) ]] &&
  dh_error 99 "$DHQ_QEMUBIN not found"

case $1 in
  boot)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run
    dh_mklock
    dh_preboot
    dh_createdisks
    dh_showqemu
    dh_boot &
    sleep 1
    ;;
  bootall)
    [[ -z $DHQ_AUTO ]] && dh_error 99 "DHQ_AUTO is undefined in $DHQ_CONF"
    for guest in $DHQ_AUTO; do
      dh_getconf
      dh_getguestconf $guest
      if [[ -n $(/bin/ps xa | grep "uuid $DHQ_UUID" | grep -v grep) ]]; then
        echo $guest is already running
        continue
      fi
      dh_mklock
      dh_preboot
      dh_createdisks
      dh_boot &
      sleep 1
    done
    ;;
  iceboot)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run
    dh_mklock
    DHQ_SUSPEND="-S"
    dh_preboot
    dh_createdisks
    dh_showqemu
    dh_boot &
    ;;
  show)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_preboot
    dh_showqemu
    ;;
  reset|reboot)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo system_reset | dh_monitor
    dh_error $? "unable to issue quit command"
    echo success
    ;;
  freeze)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo stop | dh_monitor
    dh_error $? "unable to issue freeze command"
    echo success
    ;;
  thaw)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo cont | dh_monitor
    dh_error $? "unable to issue continue command"
    echo success
    ;;
  wake)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo system_wakeup | dh_monitor
    dh_error $? "unable to issue system_wakeup"
    echo success
    ;;
  shut|shutdown|poweroff)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    dh_shutdown
    dh_killswtpm
    ;;
  shutall)
    [[ -z $DHQ_AUTO ]] && dh_error 99 "DHQ_AUTO is undefined in $DHQ_CONF"
    for guest in $DHQ_AUTO; do
      dh_getguestconf $guest

      if [[ -z $(/bin/ps xa | grep "uuid $DHQ_UUID" | grep -v grep) ]]; then
        echo $guest is not running
        continue
      fi
      dh_shutdown
      dh_killswtpm
    done
    ;;
  kill)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo quit | dh_monitor
    dh_error $? "unable to issue quit command"
    dh_killswtpm
    echo success
    ;;
  killall)
    [[ -z $DHQ_AUTO ]] && dh_error 99 "DHQ_AUTO is undefined in $DHQ_CONF"

    for guest in $DHQ_AUTO; do
      dh_getguestconf $guest
      if [[ -z $(/bin/ps xa | grep "uuid $DHQ_UUID" | grep -v grep) ]]; then
        echo $guest is not running
        continue
      fi
      echo killing guest $guest
      echo quit | dh_monitor
      dh_error $? "unable to issue quit command"
      dh_killswtpm
    done
    ;;
  mon)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    dh_monitor
    dh_error $? "unable to connect to qemu monitor socket"
    ;;
  list)
    [[ -z "$(ls $DHQ_CONFDIR/*.dhqemu)" ]] &&
      dh_error 99 "no .conf files found in $DHQ_CONFDIR"

    dh_header
  source "$DHQ_CONFDIR/$1.dhqemu" &>/dev/null

    echo
    echo "vmname           uuid                                  path"
    echo ---------------------------------------------------------------------------

    for vm in $DHQ_CONFDIR/*.dhqemu; do
      dh_getconf
      source $vm
      dh_error $? "error reading $vm"
      dh_getguestconf $DHQ_VMNAME
      [[ -z $DHQ_UUID || $DHQ_UUID == "generate" ]] && DHQ_UUID="will-be-generated"
      printf "%-15s  %-36s  %s\n" $DHQ_VMNAME $DHQ_UUID $DHQ_VMPATH/$DHQ_VMNAME
    done
    echo
    ;;
  pid)
    ps -fC $DHQ_QEMUBIN
    ;;
  dir)
    [[ -z "$2" ]] && dh_usage
    dh_getconf
    dh_getguestconf $2
    echo folder location: $DHQ_VMPATH/$DHQ_VMNAME
    echo -------------------------------------------------
    ls -laF "$DHQ_VMPATH/$DHQ_VMNAME"
    ;;
  back|backup)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run
    dh_backup
    echo success
    ;;
  unmap)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo "device_del mapusb" | dh_monitor
    dh_error $? "unable to issue device_del command"
    echo success
    ;;
  map)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    [[ ! -f "$3" ]] &&
      dh_error 99 "unable to access file: $3"
    dh_runcheck norun
    printf "%s\n%s\n" "drive_add 0 if=none,id=mapusb,file=$3" "device_add usb-storage,drive=dhplugdrv,id=mapusb" | dh_monitor
    dh_error $? "unable to issue device_add command"
    echo success
    ;;
  unplug)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck norun
    echo "device_del usbplug" | dh_monitor
    dh_error $? "unable to issue device_del command"
    echo success
    ;;
  plug)
    [[ -z "$2" || -z "$3" || -z "$4" ]] && dh_usage

    if [[ -n "$5" ]]; then
      vmbus=$5
    else
      vmbus="usb.0"
    fi

    dh_getguestconf $2
    u1="00$3"
    u2="00$4"
    hostbus="${u1: -3}"
    hostdev="${u2: -3}"

    [[ ! -c /dev/bus/usb/$hostbus/$hostdev ]] &&
      dh_error 99 "local usb dev not found: $hostbus $hostdev"

    dh_runcheck norun
    sudo chown $UID /dev/bus/usb/$hostbus/$hostdev
    retcode=$?

    [[ $retcode -ne 0 ]] &&
      dh_error $retcode "unable to change ownership of usb device $hostbus $hostdev"

    echo "device_add usb-host,hostbus=$3,hostaddr=$4,bus=$vmbus,id=usbplug" | dh_monitor
    if [[ $? != 0 ]]; then
      sudo chown root /dev/bus/usb/$hostbus/$hostdev
      dh_error 99 "failed to issue device_add command"
    fi

    echo success
    ;;
  clone|copy)
    [[ -z $2 || -z $3 ]] && dh_usage
    cp -v "$DHQ_CONFDIR/$2.dhqemu" "$DHQ_CONFDIR/$3.dhqemu"
    dh_error $? "unable to copy $2 to $3"
    sed -i -e "/^DHQ_VMNAME=/ s/DHQ_VMNAME.*/DHQ_VMNAME=\"$3\"/" "$DHQ_CONFDIR/$3.dhqemu"
    dh_error $? "unable to update $3.conf name. please validate."
    echo success
    ;;
  commit)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run
    dh_commit $3
    ;;
  revert)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run
    dh_revert $3
    ;;
  erase)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run
    dh_erase $3
    ;;
  delete)
    [[ -z "$2" ]] && dh_usage
    dh_getguestconf $2
    dh_runcheck run

    [[ ! -d "$DHQ_VMPATH/$DHQ_VMNAME" ]] && dh_error 99 "$DHQ_VMPATH/$DHQ_VMNAME does not exist"

    rm -rvf "$DHQ_VMPATH/$DHQ_VMNAME"
    dh_error $? "unable to remove folder $DHQ_VMPATH/$DHQ_VMNAME"
    echo success
    ;;
  *)
    dh_header
    dh_usage
    ;;
esac

exit 0
